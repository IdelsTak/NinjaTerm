package ninja.mbedded.ninjaterm.util.streamedText;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import ninja.mbedded.ninjaterm.util.debugging.Debugging;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

/**
 * Class which is designed to encapsulate a "unit" of streamed text, which is generated by the ANSI escape
 * code parser. This <code>{@link StreamedTextV2}</code> object is then fed into the filter engine,
 * whose output is another <code>{@link StreamedTextV2}</code> object.
 *
 * @author Geoffrey Hunter <gbmhunter@gmail.com> (www.mbedded.ninja)
 * @since 2016-09-28
 * @last-modified 2016-10-02
 */
public class StreamedTextV2 {

    private String text = "";
    private List<TextColourV2> textColours = new ArrayList<>();
    private Color colorToBeInsertedOnNextChar = null;


    public String getText() {
        return text;
    }

    public List<TextColourV2> getTextColours () {
        return textColours;
    }

    public Color getColorToBeInsertedOnNextChar() {
        return colorToBeInsertedOnNextChar;
    }

    public void setColorToBeInsertedOnNextChar(Color color) {
        this.colorToBeInsertedOnNextChar = color;
    }

    /**
     * The method extracts the specified number of chars from the input and places them in the output.
     * It extract chars from the "to append" String first, and then starts removing chars from the first of the
     * Text nodes contained within the list.
     * <p>
     * It also shifts any chars from still existing input nodes into the "to append" String
     * as appropriate.
     *
     * @param numChars
     * @return
     */
    public void shiftCharsIn(StreamedTextV2 inputStreamedText, int numChars) {

        for (ListIterator<TextColourV2> iter = inputStreamedText.textColours.listIterator(); iter.hasNext(); ) {
            TextColourV2 textColourV2 = iter.next();

            // Check if we have reached TextColour objects which index characters beyond the range
            // we are shifting, and if so, break out of this loop
            if(textColourV2.position < numChars) {
                // We need to offset set the position by the length of the existing text
                textColourV2.position = textColourV2.position + text.length();

                // Now add this TextColour object to this objects list, and remove from the input
                textColours.add(textColourV2);
                iter.remove();
            } else {
                // We are beyond the range that is being shifted, so adjust the position, but
                // don't shift the object to this list (keep in input)
                textColourV2.position -= numChars;
            }
        }

        text = text + inputStreamedText.text.substring(0, numChars);
        inputStreamedText.text = inputStreamedText.text.substring(numChars, inputStreamedText.text.length());

        // Apply the colour to be inserted on next char, if at least one char was placed in the output
        if((numChars > 0) && (this.colorToBeInsertedOnNextChar != null)) {

            // Check if a color is already assigned to this character. If so, do not
            // overwrite
            if(this.textColours.get(0).position != 0) {
                // Insert new TextColour object at start of list
                this.textColours.add(0, new TextColourV2(0, this.colorToBeInsertedOnNextChar));
            }

            // We have applied the color to a character, remove the placeholder
            this.colorToBeInsertedOnNextChar = null;
        }

        // Transfer the "color to be inserted on next char", if one exists in input
        // This could overwrite an existing "color to be inserted on next char" in the output, if
        // no chars were shifted
        if(inputStreamedText.getColorToBeInsertedOnNextChar() != null) {
            this.addColour(this.getText().length(), inputStreamedText.getColorToBeInsertedOnNextChar());
            inputStreamedText.setColorToBeInsertedOnNextChar(null);
        }

    }

    public void removeChars(int numChars) {
        StreamedTextV2 dummyStreamedText = new StreamedTextV2();
        dummyStreamedText.shiftCharsIn(this, numChars);
    }

    /**
     * The method copies the specified number of chars from the input into the output.
     * It copies chars from the "to append" String first, and then starts copying chars from the first of the
     * Text nodes contained within the list.
     * <p>
     * It also copies any chars from still existing input nodes into the "to append" String
     * as appropriate.
     *
     * @param inputStreamedText
     * @param numChars
     * @return
     */
    public static void copyChars(StreamedTextV2 inputStreamedText, StreamedTextV2 outputStreamedText, int numChars) {

        if (numChars < 0)
            throw new IllegalArgumentException("numChars cannot be negative.");


    }

    public static void copyAnyEmptyNodes(StreamedTextV2 inputStreamedText, StreamedTextV2 outputStreamedText) {


    }

    /**
     * Adds the provided text to the stream, using the given <code>addMethod</code>.
     *
     * @param textToAppend
     */
    public void append(String textToAppend) {
        System.out.println("append() called with text = \"" + Debugging.convertNonPrintable(textToAppend) + "\".");

        text = text + textToAppend;

    }

    public void addColour(int position, Color color) {

        if(position < 0 || position > text.length())
            throw new RuntimeException("position was either too small or too large.");

        // Check if colour needs to be added
        if(position == text.length()) {
            colorToBeInsertedOnNextChar = color;
        } else {
            textColours.add(new TextColourV2(position, color));
        }

    }


    @Override
    public String toString() {
        return text;
    }
}
